stack implementation :


import java.util.Scanner;

public class stackimplementation {
    private int maxSize;
    private int[] stackArray;
    private int top;

    public stackimplementation(int size) {
        maxSize = size;
        stackArray = new int[maxSize];
        top = -1;
    }

    public void push(int value) {
        if (top == maxSize - 1) {
            System.out.println("Stack is full!");
        } else {
            stackArray[++top] = value;
            System.out.println(value + " pushed into stack.");
        }
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return -1;
        } else {
            int value = stackArray[top--];
            System.out.println(value + " popped from stack.");
            return value;
        }
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty!");
            return -1;
        } else {
            return stackArray[top];
        }
    }

    public boolean isEmpty() {
        return (top == -1);
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print("Enter size of stack: ");
        int size = input.nextInt();

        stackimplementation stack = new stackimplementation(size);

        while (true) {
            System.out.println("\n--- Stack Menu ---");
            System.out.println("1. Push");
            System.out.println("2. Pop");
            System.out.println("3. Peek");
            System.out.println("4. Check if Empty");
            System.out.println("5. Exit");
            System.out.print("Choose option: ");
            int choice = input.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter value to push: ");
                    int value = input.nextInt();
                    stack.push(value);
                    break;

                case 2:
                    stack.pop();
                    break;

                case 3:
                    System.out.println("Top element: " + stack.peek());
                    break;

                case 4:
                    System.out.println("Is stack empty? " + stack.isEmpty());
                    break;

                case 5:
                    System.out.println("Exiting program...");
                    input.close();
                    return;

                default:
                    System.out.println("Invalid choice! Try again.");
            }
        }
    }
}

INFIX TO POSTFIX:
import java.util.Stack;

public class infixtopostfix {


    static int priority(char ch) {
        if (ch == '+' || ch == '-') return 1;
        if (ch == '*' || ch == '/') return 2;
        if (ch == '^') return 3;
        return 0;
    }


    static String toPostfix(String infix) {
        Stack<Character> stack = new Stack<>(); 
        String postfix = "";                    

        
        for (int i = 0; i < infix.length(); i++) {
            char c = infix.charAt(i);

            
            if (Character.isLetterOrDigit(c)) {
                postfix += c;
            }

            
            else if (c == '(') {
                stack.push(c);
            }

            
            else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix += stack.pop();
                }
                stack.pop(); 
            }

            
            
            else {
                while (!stack.isEmpty() && priority(c) <= priority(stack.peek())) {
                    postfix += stack.pop(); 
                }
                stack.push(c); 
            }
        }

       
        while (!stack.isEmpty()) {
            postfix += stack.pop();
        }

        return postfix;
    }

    public static void main(String[] args) {
        String infix = "(A+B)*(C-D)";

        System.out.println("Infix Expression: " + infix);
        System.out.println("Postfix Expression: " + toPostfix(infix));
    }
}
INFIX TO PREFIX:
import java.util.*;

public class infixtoprefix {
    
  
    static int precedence(char ch) {
        switch (ch) {
            case '+': case '-': return 1;
            case '*': case '/': return 2;
            case '^': return 3;
        }
        return -1;
    }

    static String infixToPostfix(String infix) {
        Stack<Character> stack = new Stack<>();
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < infix.length(); i++) {
            char c = infix.charAt(i);

          
            if (c == ' ') continue;

            
            if (Character.isLetterOrDigit(c)) {
                result.append(c);
            }
            
            else if (c == '(') {
                stack.push(c);
            }
          
            else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    result.append(stack.pop());
                }
                stack.pop(); 
            }

            else {
                while (!stack.isEmpty() && precedence(c) <= precedence(stack.peek())) {
                    result.append(stack.pop());
                }
                stack.push(c);
            }
        }
      
        while (!stack.isEmpty()) result.append(stack.pop());
        return result.toString();
    }

    
    static String infixToPrefix(String infix) {
       
        StringBuilder rev = new StringBuilder(infix).reverse();
        String reversed = rev.toString();

        char[] chars = reversed.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '(') chars[i] = ')';
            else if (chars[i] == ')') chars[i] = '(';
        }

    
        String postfix = infixToPostfix(new String(chars));

    
        return new StringBuilder(postfix).reverse().toString();
    }

    public static void main(String[] args) {
        String infix = "(A + B) * (C - D)";
        System.out.println("Infix: " + infix);

        String postfix = infixToPostfix(infix);
        System.out.println("Postfix: " + postfix);

        String prefix = infixToPrefix(infix);
        System.out.println("Prefix: " + prefix);
    }
}
QUEUE IMPLEMENTATION :
import java.util.Scanner;

public class queue {
    private int front, rear, size;
    private int[] queue;

    public queue(int capacity) {
        queue = new int[capacity];
        front = -1;
        rear = -1;
        size = 0;
    }

    public void enqueue(int value) {
        if (isFull()) {
            System.out.println("Queue is full!");
            return;
        }

        if (front == -1)
            front = 0;

        rear = (rear + 1) % queue.length;
        queue[rear] = value;
        size++;

        System.out.println(value + " added to queue.");
    }

    public int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty!");
            return -1;
        }

        int value = queue[front];
        System.out.println(value + " removed from queue.");

        if (front == rear) {
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % queue.length;
        }

        size--;
        return value;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty!");
            return -1;
        }
        return queue[front];
    }

    public boolean isEmpty() {
        return (front == -1);
    }

    public boolean isFull() {
        return (front == (rear + 1) % queue.length);
    }

    // Optional: Display queue elements
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty!");
            return;
        }
        System.out.print("Queue elements: ");
        int i = front;
        while (true) {
            System.out.print(queue[i] + " ");
            if (i == rear) break;
            i = (i + 1) % queue.length;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter queue capacity: ");
        int capacity = sc.nextInt();

        queue q = new queue(capacity);

        int choice;
        do {
            System.out.println("\n--- Queue Menu ---");
            System.out.println("1. Enqueue (Add)");
            System.out.println("2. Dequeue (Remove)");
            System.out.println("3. Peek (Front element)");
            System.out.println("4. Display Queue");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");
            choice = sc.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter value to add: ");
                    int value = sc.nextInt();
                    q.enqueue(value);
                    break;
                case 2:
                    q.dequeue();
                    break;
                case 3:
                    System.out.println("Front element: " + q.peek());
                    break;
                case 4:
                    q.display();
                    break;
                case 5:
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice! Try again.");
            }
        } while (choice != 5);

        sc.close();
    }
}


PRINTER QUEUE:

import java.util.LinkedList;
import java.util.Queue;

public class printerqueue{
    public static void main(String[] args) {
        Queue<String> printerQueue = new LinkedList<>();

    
        printerQueue.add("Document1");
        System.out.println("Enqueued: Document1");
        printerQueue.add("Document2");
        System.out.println("Enqueued: Document2");
        printerQueue.add("Document3");
        System.out.println("Enqueued: Document3");

        System.out.println("\nProcessing jobs...");

        while (!printerQueue.isEmpty()) {
            String job = printerQueue.poll(); 
            System.out.println("Processing: " + job);
            System.out.println("Remaining Queue: " + printerQueue);
        }

        System.out.println("\nAll jobs processed successfully!");
    }
}


